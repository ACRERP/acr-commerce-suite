-- =====================================================
-- SISTEMA DE ALERTAS
-- Data: 08/12/2025
-- Funcionalidades: Alertas automáticos, notificações,
--                  prioridades, estatísticas
-- =====================================================

-- ============ TABELA DE ALERTAS ============

CREATE TABLE IF NOT EXISTS public.alerts (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  tipo VARCHAR(50) NOT NULL CHECK (tipo IN (
    'os_vencida', 
    'os_vencendo', 
    'conta_vencida', 
    'conta_vencendo', 
    'estoque_baixo', 
    'delivery_atrasado', 
    'meta_atingida', 
    'cliente_inadimplente'
  )),
  modulo VARCHAR(50) NOT NULL CHECK (modulo IN ('os', 'financeiro', 'estoque', 'delivery', 'vendas')),
  prioridade VARCHAR(20) NOT NULL CHECK (prioridade IN ('baixa', 'media', 'alta', 'critica')),
  titulo VARCHAR(200) NOT NULL,
  mensagem TEXT NOT NULL,
  referencia_id BIGINT,
  referencia_tipo VARCHAR(50),
  lido BOOLEAN DEFAULT false,
  acao_url TEXT,
  acao_label VARCHAR(100),
  usuario_id UUID REFERENCES auth.users(id),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

COMMENT ON TABLE public.alerts IS 'Sistema de alertas e notificações';
COMMENT ON COLUMN public.alerts.tipo IS 'Tipo do alerta';
COMMENT ON COLUMN public.alerts.modulo IS 'Módulo de origem';
COMMENT ON COLUMN public.alerts.prioridade IS 'Nível de prioridade';
COMMENT ON COLUMN public.alerts.referencia_id IS 'ID do registro relacionado';
COMMENT ON COLUMN public.alerts.referencia_tipo IS 'Tipo do registro (service_order, account_receivable, etc)';
COMMENT ON COLUMN public.alerts.acao_url IS 'URL para ação do alerta';
COMMENT ON COLUMN public.alerts.acao_label IS 'Label do botão de ação';

-- Índices para performance
CREATE INDEX IF NOT EXISTS idx_alerts_lido ON public.alerts(lido);
CREATE INDEX IF NOT EXISTS idx_alerts_prioridade ON public.alerts(prioridade);
CREATE INDEX IF NOT EXISTS idx_alerts_modulo ON public.alerts(modulo);
CREATE INDEX IF NOT EXISTS idx_alerts_usuario_id ON public.alerts(usuario_id);
CREATE INDEX IF NOT EXISTS idx_alerts_created_at ON public.alerts(created_at);
CREATE INDEX IF NOT EXISTS idx_alerts_tipo ON public.alerts(tipo);

-- ============ VIEWS ============

-- View de estatísticas gerais
CREATE OR REPLACE VIEW vw_alert_stats AS
SELECT 
  COUNT(*) as total_alertas,
  COUNT(CASE WHEN NOT lido THEN 1 END) as nao_lidas,
  COUNT(CASE WHEN prioridade = 'critica' THEN 1 END) as criticas,
  COUNT(CASE WHEN prioridade = 'alta' THEN 1 END) as altas,
  COUNT(CASE WHEN prioridade = 'media' THEN 1 END) as medias,
  COUNT(CASE WHEN prioridade = 'baixa' THEN 1 END) as baixas
FROM alerts
WHERE created_at > NOW() - INTERVAL '7 days';

-- View de alertas por módulo
CREATE OR REPLACE VIEW vw_alerts_por_modulo AS
SELECT 
  modulo,
  COUNT(*) as total,
  COUNT(CASE WHEN NOT lido THEN 1 END) as nao_lidas,
  COUNT(CASE WHEN prioridade = 'critica' THEN 1 END) as criticas
FROM alerts
WHERE created_at > NOW() - INTERVAL '7 days'
GROUP BY modulo
ORDER BY total DESC;

-- View de alertas críticos não lidos
CREATE OR REPLACE VIEW vw_critical_alerts AS
SELECT 
  id,
  tipo,
  modulo,
  titulo,
  mensagem,
  referencia_id,
  referencia_tipo,
  acao_url,
  acao_label,
  created_at
FROM alerts
WHERE 
  prioridade = 'critica'
  AND NOT lido
ORDER BY created_at DESC;

-- View de alertas recentes
CREATE OR REPLACE VIEW vw_recent_alerts AS
SELECT 
  id,
  tipo,
  modulo,
  prioridade,
  titulo,
  mensagem,
  lido,
  created_at
FROM alerts
WHERE created_at > NOW() - INTERVAL '24 hours'
ORDER BY created_at DESC;

-- ============ FUNÇÕES ============

-- Função para limpar alertas antigos
CREATE OR REPLACE FUNCTION fn_clean_old_alerts(days_to_keep INTEGER DEFAULT 30)
RETURNS INTEGER AS $$
DECLARE
  deleted_count INTEGER;
BEGIN
  DELETE FROM alerts
  WHERE 
    created_at < NOW() - (days_to_keep || ' days')::INTERVAL
    AND lido = true;
  
  GET DIAGNOSTICS deleted_count = ROW_COUNT;
  RETURN deleted_count;
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION fn_clean_old_alerts IS 'Remove alertas lidos antigos (padrão: 30 dias)';

-- Função para criar alerta de OS vencida
CREATE OR REPLACE FUNCTION fn_create_os_vencida_alert()
RETURNS INTEGER AS $$
DECLARE
  alert_count INTEGER := 0;
  os_record RECORD;
BEGIN
  FOR os_record IN 
    SELECT 
      so.id,
      so.numero,
      c.name as cliente_nome
    FROM service_orders so
    JOIN clients c ON c.id = so.client_id
    WHERE 
      so.status_prazo = 'vencida'
      AND so.status NOT IN ('entregue', 'cancelada')
      AND NOT EXISTS (
        SELECT 1 FROM alerts
        WHERE tipo = 'os_vencida'
        AND referencia_id = so.id
        AND NOT lido
      )
  LOOP
    INSERT INTO alerts (tipo, modulo, prioridade, titulo, mensagem, referencia_id, referencia_tipo, lido, acao_url, acao_label)
    VALUES (
      'os_vencida',
      'os',
      'alta',
      'OS #' || os_record.numero || ' Vencida',
      'A OS #' || os_record.numero || ' do cliente ' || os_record.cliente_nome || ' está vencida!',
      os_record.id,
      'service_order',
      false,
      '/os/' || os_record.id,
      'Ver OS'
    );
    
    alert_count := alert_count + 1;
  END LOOP;
  
  RETURN alert_count;
END;
$$ LANGUAGE plpgsql;

-- Função para criar alerta de estoque baixo
CREATE OR REPLACE FUNCTION fn_create_estoque_baixo_alert()
RETURNS INTEGER AS $$
DECLARE
  alert_count INTEGER := 0;
  product_record RECORD;
BEGIN
  FOR product_record IN 
    SELECT 
      id,
      name,
      stock_quantity,
      min_stock
    FROM products
    WHERE 
      stock_quantity <= min_stock
      AND NOT EXISTS (
        SELECT 1 FROM alerts
        WHERE tipo = 'estoque_baixo'
        AND referencia_id = products.id
        AND NOT lido
      )
  LOOP
    INSERT INTO alerts (tipo, modulo, prioridade, titulo, mensagem, referencia_id, referencia_tipo, lido, acao_url, acao_label)
    VALUES (
      'estoque_baixo',
      'estoque',
      'media',
      'Estoque Baixo',
      product_record.name || ' está com estoque baixo (' || product_record.stock_quantity || ' unidades)!',
      product_record.id,
      'product',
      false,
      '/produtos/' || product_record.id,
      'Ver Produto'
    );
    
    alert_count := alert_count + 1;
  END LOOP;
  
  RETURN alert_count;
END;
$$ LANGUAGE plpgsql;

-- Função para processar todos os alertas
CREATE OR REPLACE FUNCTION fn_process_all_alerts()
RETURNS TABLE (
  os_vencidas INTEGER,
  estoque_baixo INTEGER,
  total INTEGER
) AS $$
DECLARE
  os_count INTEGER;
  estoque_count INTEGER;
BEGIN
  os_count := fn_create_os_vencida_alert();
  estoque_count := fn_create_estoque_baixo_alert();
  
  RETURN QUERY SELECT os_count, estoque_count, os_count + estoque_count;
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION fn_process_all_alerts IS 'Processa todos os tipos de alertas automáticos';

-- ============ RLS (Row Level Security) ============

ALTER TABLE public.alerts ENABLE ROW LEVEL SECURITY;

-- Políticas
CREATE POLICY "Usuários autenticados podem ver alertas" ON public.alerts FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Usuários autenticados podem criar alertas" ON public.alerts FOR INSERT WITH CHECK (auth.role() = 'authenticated');
CREATE POLICY "Usuários autenticados podem atualizar alertas" ON public.alerts FOR UPDATE USING (auth.role() = 'authenticated');
CREATE POLICY "Usuários autenticados podem deletar alertas" ON public.alerts FOR DELETE USING (auth.role() = 'authenticated');

-- ============ AGENDAMENTO AUTOMÁTICO ============

-- Criar extensão pg_cron se não existir (requer superuser)
-- CREATE EXTENSION IF NOT EXISTS pg_cron;

-- Agendar processamento de alertas a cada 5 minutos
-- SELECT cron.schedule('process-alerts', '*/5 * * * *', 'SELECT fn_process_all_alerts()');

-- Agendar limpeza de alertas antigos diariamente às 3h
-- SELECT cron.schedule('clean-old-alerts', '0 3 * * *', 'SELECT fn_clean_old_alerts(30)');

-- ============ COMENTÁRIOS FINAIS ============

COMMENT ON COLUMN public.alerts.lido IS 'Indica se o alerta foi lido pelo usuário';
COMMENT ON COLUMN public.alerts.usuario_id IS 'ID do usuário (null = todos os usuários)';
