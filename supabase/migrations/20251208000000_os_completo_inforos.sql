-- =====================================================
-- MÓDULO OS COMPLETO - Inspirado em InforOS
-- Data: 08/12/2025
-- Funcionalidades: Prazo, Prioridade, Acessórios, Fotos,
--                  Notas, Produtividade, WhatsApp, Marketing
-- =====================================================

-- ============ EXPANSÃO DA TABELA PRINCIPAL ============

-- Adicionar novos campos à tabela service_orders
ALTER TABLE public.service_orders 
ADD COLUMN IF NOT EXISTS numero VARCHAR(20) UNIQUE,
ADD COLUMN IF NOT EXISTS prioridade VARCHAR(20) DEFAULT 'media',
ADD COLUMN IF NOT EXISTS prazo_entrega TIMESTAMP WITH TIME ZONE,
ADD COLUMN IF NOT EXISTS status_prazo VARCHAR(20),
ADD COLUMN IF NOT EXISTS dias_restantes INTEGER,
ADD COLUMN IF NOT EXISTS data_inicio_reparo TIMESTAMP WITH TIME ZONE,
ADD COLUMN IF NOT EXISTS data_conclusao TIMESTAMP WITH TIME ZONE,
ADD COLUMN IF NOT EXISTS diagnostico TEXT,
ADD COLUMN IF NOT EXISTS solucao_proposta TEXT,
ADD COLUMN IF NOT EXISTS valor_servicos DECIMAL(10,2) DEFAULT 0,
ADD COLUMN IF NOT EXISTS valor_pecas DECIMAL(10,2) DEFAULT 0,
ADD COLUMN IF NOT EXISTS valor_total DECIMAL(10,2) DEFAULT 0,
ADD COLUMN IF NOT EXISTS desconto DECIMAL(10,2) DEFAULT 0,
ADD COLUMN IF NOT EXISTS valor_final DECIMAL(10,2),
ADD COLUMN IF NOT EXISTS orcamento_aprovado BOOLEAN DEFAULT false,
ADD COLUMN IF NOT EXISTS data_aprovacao TIMESTAMP WITH TIME ZONE,
ADD COLUMN IF NOT EXISTS termo_entrada TEXT,
ADD COLUMN IF NOT EXISTS termo_garantia TEXT,
ADD COLUMN IF NOT EXISTS assinatura_cliente TEXT,
ADD COLUMN IF NOT EXISTS data_assinatura TIMESTAMP WITH TIME ZONE,
ADD COLUMN IF NOT EXISTS data_entrega TIMESTAMP WITH TIME ZONE,
ADD COLUMN IF NOT EXISTS entregue_para VARCHAR(200),
ADD COLUMN IF NOT EXISTS documento_entrega VARCHAR(50),
ADD COLUMN IF NOT EXISTS origem_cliente VARCHAR(100),
ADD COLUMN IF NOT EXISTS feedback_enviado BOOLEAN DEFAULT false,
ADD COLUMN IF NOT EXISTS avaliacao INTEGER CHECK (avaliacao >= 1 AND avaliacao <= 5),
ADD COLUMN IF NOT EXISTS comentario_avaliacao TEXT;

-- Criar índices para performance
CREATE INDEX IF NOT EXISTS idx_service_orders_status_prazo ON public.service_orders(status_prazo);
CREATE INDEX IF NOT EXISTS idx_service_orders_prioridade ON public.service_orders(prioridade);
CREATE INDEX IF NOT EXISTS idx_service_orders_prazo_entrega ON public.service_orders(prazo_entrega);
CREATE INDEX IF NOT EXISTS idx_service_orders_user_id ON public.service_orders(user_id);
CREATE INDEX IF NOT EXISTS idx_service_orders_created_at ON public.service_orders(created_at);

-- ============ TABELAS COMPLEMENTARES ============

-- Tabela de Acessórios
CREATE TABLE IF NOT EXISTS public.service_order_accessories (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  service_order_id BIGINT NOT NULL REFERENCES public.service_orders(id) ON DELETE CASCADE,
  descricao VARCHAR(200) NOT NULL,
  quantidade INTEGER DEFAULT 1,
  devolvido BOOLEAN DEFAULT false,
  foto_url TEXT,
  observacoes TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_accessories_service_order ON public.service_order_accessories(service_order_id);

-- Tabela de Fotos
CREATE TABLE IF NOT EXISTS public.service_order_photos (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  service_order_id BIGINT NOT NULL REFERENCES public.service_orders(id) ON DELETE CASCADE,
  tipo VARCHAR(20) NOT NULL CHECK (tipo IN ('entrada', 'durante', 'saida', 'defeito')),
  url TEXT NOT NULL,
  descricao TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_photos_service_order ON public.service_order_photos(service_order_id);

-- Tabela de Notas/Anotações
CREATE TABLE IF NOT EXISTS public.service_order_notes (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  service_order_id BIGINT NOT NULL REFERENCES public.service_orders(id) ON DELETE CASCADE,
  tipo VARCHAR(20) NOT NULL CHECK (tipo IN ('publica', 'interna')),
  conteudo TEXT NOT NULL,
  usuario_id UUID REFERENCES auth.users(id),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_notes_service_order ON public.service_order_notes(service_order_id);

-- Tabela de Serviços da OS
CREATE TABLE IF NOT EXISTS public.service_order_services (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  service_order_id BIGINT NOT NULL REFERENCES public.service_orders(id) ON DELETE CASCADE,
  descricao VARCHAR(200) NOT NULL,
  quantidade DECIMAL(10,2) DEFAULT 1,
  valor_unitario DECIMAL(10,2) NOT NULL,
  valor_total DECIMAL(10,2) NOT NULL,
  tecnico_id UUID REFERENCES auth.users(id),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_services_service_order ON public.service_order_services(service_order_id);

-- Tabela de Peças da OS
CREATE TABLE IF NOT EXISTS public.service_order_parts (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  service_order_id BIGINT NOT NULL REFERENCES public.service_orders(id) ON DELETE CASCADE,
  produto_id BIGINT REFERENCES public.products(id),
  descricao VARCHAR(200),
  quantidade DECIMAL(10,2) NOT NULL,
  valor_unitario DECIMAL(10,2) NOT NULL,
  valor_total DECIMAL(10,2) NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_parts_service_order ON public.service_order_parts(service_order_id);

-- Tabela de Histórico de Status
CREATE TABLE IF NOT EXISTS public.service_order_history (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  service_order_id BIGINT NOT NULL REFERENCES public.service_orders(id) ON DELETE CASCADE,
  status_anterior VARCHAR(50),
  status_novo VARCHAR(50) NOT NULL,
  usuario_id UUID REFERENCES auth.users(id),
  observacao TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_history_service_order ON public.service_order_history(service_order_id);

-- Tabela de Mensagens WhatsApp (Log)
CREATE TABLE IF NOT EXISTS public.service_order_whatsapp_log (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  service_order_id BIGINT NOT NULL REFERENCES public.service_orders(id) ON DELETE CASCADE,
  tipo VARCHAR(50) NOT NULL, -- status_update, pdf, reminder, feedback, cobranca
  telefone VARCHAR(20) NOT NULL,
  mensagem TEXT NOT NULL,
  enviado BOOLEAN DEFAULT false,
  data_envio TIMESTAMP WITH TIME ZONE,
  erro TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_whatsapp_service_order ON public.service_order_whatsapp_log(service_order_id);

-- ============ FUNÇÕES ============

-- Função para calcular status de prazo
CREATE OR REPLACE FUNCTION fn_calcular_status_prazo()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.prazo_entrega IS NOT NULL THEN
    NEW.dias_restantes := EXTRACT(DAY FROM (NEW.prazo_entrega - NOW()));
    
    IF NEW.prazo_entrega < NOW() THEN
      NEW.status_prazo := 'vencida';
    ELSIF NEW.dias_restantes <= 1 THEN
      NEW.status_prazo := 'vencendo';
    ELSIF NEW.dias_restantes <= 2 THEN
      NEW.status_prazo := 'no_limite';
    ELSE
      NEW.status_prazo := 'no_prazo';
    END IF;
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Função para gerar número sequencial de OS
CREATE OR REPLACE FUNCTION fn_gerar_numero_os()
RETURNS TRIGGER AS $$
DECLARE
  ano_atual VARCHAR(4);
  proximo_numero INTEGER;
  numero_formatado VARCHAR(20);
BEGIN
  IF NEW.numero IS NULL THEN
    ano_atual := TO_CHAR(NOW(), 'YYYY');
    
    SELECT COALESCE(MAX(CAST(SUBSTRING(numero FROM 6) AS INTEGER)), 0) + 1
    INTO proximo_numero
    FROM service_orders
    WHERE numero LIKE ano_atual || '%';
    
    numero_formatado := ano_atual || LPAD(proximo_numero::TEXT, 6, '0');
    NEW.numero := numero_formatado;
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Função para calcular valor total
CREATE OR REPLACE FUNCTION fn_calcular_valor_total_os()
RETURNS TRIGGER AS $$
BEGIN
  NEW.valor_total := COALESCE(NEW.valor_servicos, 0) + COALESCE(NEW.valor_pecas, 0);
  NEW.valor_final := NEW.valor_total - COALESCE(NEW.desconto, 0);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Função para registrar histórico de status
CREATE OR REPLACE FUNCTION fn_registrar_historico_status()
RETURNS TRIGGER AS $$
BEGIN
  IF OLD.status IS DISTINCT FROM NEW.status THEN
    INSERT INTO service_order_history (service_order_id, status_anterior, status_novo, usuario_id)
    VALUES (NEW.id, OLD.status::TEXT, NEW.status::TEXT, auth.uid());
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- ============ TRIGGERS ============

-- Trigger para calcular status de prazo
DROP TRIGGER IF EXISTS trg_calcular_status_prazo ON public.service_orders;
CREATE TRIGGER trg_calcular_status_prazo
  BEFORE INSERT OR UPDATE OF prazo_entrega ON public.service_orders
  FOR EACH ROW
  EXECUTE FUNCTION fn_calcular_status_prazo();

-- Trigger para gerar número de OS
DROP TRIGGER IF EXISTS trg_gerar_numero_os ON public.service_orders;
CREATE TRIGGER trg_gerar_numero_os
  BEFORE INSERT ON public.service_orders
  FOR EACH ROW
  EXECUTE FUNCTION fn_gerar_numero_os();

-- Trigger para calcular valor total
DROP TRIGGER IF EXISTS trg_calcular_valor_total_os ON public.service_orders;
CREATE TRIGGER trg_calcular_valor_total_os
  BEFORE INSERT OR UPDATE OF valor_servicos, valor_pecas, desconto ON public.service_orders
  FOR EACH ROW
  EXECUTE FUNCTION fn_calcular_valor_total_os();

-- Trigger para registrar histórico
DROP TRIGGER IF EXISTS trg_registrar_historico_status ON public.service_orders;
CREATE TRIGGER trg_registrar_historico_status
  AFTER UPDATE OF status ON public.service_orders
  FOR EACH ROW
  EXECUTE FUNCTION fn_registrar_historico_status();

-- ============ VIEWS ============

-- View de Produtividade de Técnicos
CREATE OR REPLACE VIEW vw_technician_productivity AS
SELECT 
  u.id as tecnico_id,
  u.email as nome,
  COUNT(CASE WHEN so.status = 'concluida' THEN 1 END) as os_concluidas,
  COUNT(CASE WHEN so.status IN ('em_andamento', 'aguardando_peca') THEN 1 END) as os_em_andamento,
  ROUND(AVG(EXTRACT(EPOCH FROM (so.data_conclusao - so.data_inicio_reparo))/3600)::NUMERIC, 2) as tempo_medio_horas,
  ROUND((COUNT(CASE WHEN so.orcamento_aprovado THEN 1 END)::DECIMAL / NULLIF(COUNT(*), 0) * 100), 2) as taxa_aprovacao,
  SUM(CASE WHEN so.status = 'concluida' THEN COALESCE(so.valor_servicos, 0) ELSE 0 END) as faturamento_servicos,
  SUM(CASE WHEN so.status = 'concluida' THEN COALESCE(so.valor_pecas, 0) ELSE 0 END) as faturamento_pecas,
  SUM(CASE WHEN so.status = 'concluida' THEN COALESCE(so.valor_final, 0) ELSE 0 END) as faturamento_total
FROM auth.users u
LEFT JOIN service_orders so ON so.user_id = u.id
GROUP BY u.id, u.email;

-- View de Dashboard de OS
CREATE OR REPLACE VIEW vw_os_dashboard AS
SELECT 
  COUNT(*) as total_os,
  COUNT(CASE WHEN status = 'aberta' THEN 1 END) as os_abertas,
  COUNT(CASE WHEN status IN ('em_andamento', 'aguardando_peca') THEN 1 END) as os_em_andamento,
  COUNT(CASE WHEN status = 'concluida' THEN 1 END) as os_concluidas,
  COUNT(CASE WHEN status = 'entregue' THEN 1 END) as os_entregues,
  COUNT(CASE WHEN status = 'cancelada' THEN 1 END) as os_canceladas,
  COUNT(CASE WHEN status_prazo = 'vencida' THEN 1 END) as os_vencidas,
  COUNT(CASE WHEN status_prazo = 'vencendo' THEN 1 END) as os_vencendo,
  COUNT(CASE WHEN prioridade = 'urgente' THEN 1 END) as os_urgentes,
  COUNT(CASE WHEN prioridade = 'alta' THEN 1 END) as os_alta_prioridade,
  ROUND(AVG(COALESCE(valor_final, 0))::NUMERIC, 2) as ticket_medio,
  SUM(CASE WHEN DATE(created_at) = CURRENT_DATE THEN COALESCE(valor_final, 0) ELSE 0 END) as faturamento_dia,
  SUM(CASE WHEN DATE_TRUNC('month', created_at) = DATE_TRUNC('month', CURRENT_DATE) THEN COALESCE(valor_final, 0) ELSE 0 END) as faturamento_mes,
  ROUND((COUNT(CASE WHEN orcamento_aprovado THEN 1 END)::DECIMAL / NULLIF(COUNT(*), 0) * 100), 2) as taxa_aprovacao_geral,
  ROUND((COUNT(CASE WHEN status = 'cancelada' THEN 1 END)::DECIMAL / NULLIF(COUNT(*), 0) * 100), 2) as taxa_cancelamento
FROM service_orders;

-- View de OS por Status (para Kanban)
CREATE OR REPLACE VIEW vw_os_kanban AS
SELECT 
  so.id,
  so.numero,
  so.client_id,
  c.name as cliente_nome,
  c.phone as cliente_telefone,
  so.device_type,
  so.device_brand,
  so.device_model,
  so.reported_issue,
  so.status,
  so.prioridade,
  so.status_prazo,
  so.dias_restantes,
  so.prazo_entrega,
  so.valor_final,
  so.user_id as tecnico_id,
  u.email as tecnico_nome,
  so.created_at,
  so.updated_at
FROM service_orders so
LEFT JOIN clients c ON c.id = so.client_id
LEFT JOIN auth.users u ON u.id = so.user_id
ORDER BY 
  CASE so.prioridade
    WHEN 'urgente' THEN 1
    WHEN 'alta' THEN 2
    WHEN 'media' THEN 3
    WHEN 'baixa' THEN 4
  END,
  so.prazo_entrega ASC NULLS LAST;

-- View de Origem de Clientes
CREATE OR REPLACE VIEW vw_os_origem_clientes AS
SELECT 
  COALESCE(origem_cliente, 'Não informado') as origem,
  COUNT(*) as quantidade,
  ROUND((COUNT(*)::DECIMAL / (SELECT COUNT(*) FROM service_orders) * 100), 2) as percentual
FROM service_orders
GROUP BY origem_cliente
ORDER BY quantidade DESC;

-- View de Serviços Mais Vendidos
CREATE OR REPLACE VIEW vw_os_servicos_mais_vendidos AS
SELECT 
  sos.descricao,
  COUNT(*) as quantidade,
  SUM(sos.valor_total) as faturamento_total,
  ROUND(AVG(sos.valor_unitario)::NUMERIC, 2) as valor_medio
FROM service_order_services sos
JOIN service_orders so ON so.id = sos.service_order_id
WHERE so.status IN ('concluida', 'entregue')
GROUP BY sos.descricao
ORDER BY quantidade DESC
LIMIT 10;

-- View de Peças Mais Vendidas
CREATE OR REPLACE VIEW vw_os_pecas_mais_vendidas AS
SELECT 
  sop.descricao,
  COUNT(*) as quantidade,
  SUM(sop.valor_total) as faturamento_total,
  ROUND(AVG(sop.valor_unitario)::NUMERIC, 2) as valor_medio
FROM service_order_parts sop
JOIN service_orders so ON so.id = sop.service_order_id
WHERE so.status IN ('concluida', 'entregue')
GROUP BY sop.descricao
ORDER BY quantidade DESC
LIMIT 10;

-- ============ RLS (Row Level Security) ============

-- Habilitar RLS nas novas tabelas
ALTER TABLE public.service_order_accessories ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.service_order_photos ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.service_order_notes ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.service_order_services ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.service_order_parts ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.service_order_history ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.service_order_whatsapp_log ENABLE ROW LEVEL SECURITY;

-- Políticas para acessórios
CREATE POLICY "Usuários autenticados podem ver acessórios" ON public.service_order_accessories FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Usuários autenticados podem criar acessórios" ON public.service_order_accessories FOR INSERT WITH CHECK (auth.role() = 'authenticated');
CREATE POLICY "Usuários autenticados podem atualizar acessórios" ON public.service_order_accessories FOR UPDATE USING (auth.role() = 'authenticated');

-- Políticas para fotos
CREATE POLICY "Usuários autenticados podem ver fotos" ON public.service_order_photos FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Usuários autenticados podem criar fotos" ON public.service_order_photos FOR INSERT WITH CHECK (auth.role() = 'authenticated');

-- Políticas para notas
CREATE POLICY "Usuários autenticados podem ver notas" ON public.service_order_notes FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Usuários autenticados podem criar notas" ON public.service_order_notes FOR INSERT WITH CHECK (auth.role() = 'authenticated');

-- Políticas para serviços
CREATE POLICY "Usuários autenticados podem ver serviços" ON public.service_order_services FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Usuários autenticados podem criar serviços" ON public.service_order_services FOR INSERT WITH CHECK (auth.role() = 'authenticated');
CREATE POLICY "Usuários autenticados podem atualizar serviços" ON public.service_order_services FOR UPDATE USING (auth.role() = 'authenticated');

-- Políticas para peças
CREATE POLICY "Usuários autenticados podem ver peças" ON public.service_order_parts FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Usuários autenticados podem criar peças" ON public.service_order_parts FOR INSERT WITH CHECK (auth.role() = 'authenticated');
CREATE POLICY "Usuários autenticados podem atualizar peças" ON public.service_order_parts FOR UPDATE USING (auth.role() = 'authenticated');

-- Políticas para histórico
CREATE POLICY "Usuários autenticados podem ver histórico" ON public.service_order_history FOR SELECT USING (auth.role() = 'authenticated');

-- Políticas para WhatsApp log
CREATE POLICY "Usuários autenticados podem ver WhatsApp log" ON public.service_order_whatsapp_log FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Usuários autenticados podem criar WhatsApp log" ON public.service_order_whatsapp_log FOR INSERT WITH CHECK (auth.role() = 'authenticated');

-- ============ COMENTÁRIOS ============

COMMENT ON TABLE public.service_order_accessories IS 'Acessórios deixados junto com o equipamento na OS';
COMMENT ON TABLE public.service_order_photos IS 'Fotos do equipamento (entrada, durante reparo, saída)';
COMMENT ON TABLE public.service_order_notes IS 'Anotações públicas (visíveis ao cliente) e internas (equipe)';
COMMENT ON TABLE public.service_order_services IS 'Serviços realizados na OS';
COMMENT ON TABLE public.service_order_parts IS 'Peças utilizadas na OS';
COMMENT ON TABLE public.service_order_history IS 'Histórico de mudanças de status da OS';
COMMENT ON TABLE public.service_order_whatsapp_log IS 'Log de mensagens WhatsApp enviadas';

COMMENT ON COLUMN public.service_orders.prioridade IS 'Prioridade: baixa, media, alta, urgente';
COMMENT ON COLUMN public.service_orders.status_prazo IS 'Status do prazo: no_prazo, no_limite, vencendo, vencida';
COMMENT ON COLUMN public.service_orders.origem_cliente IS 'Como o cliente conheceu a assistência';
